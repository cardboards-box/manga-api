using System.IO.Compression;

namespace MangaBox.Services;

using Headers = Dictionary<string, string>;
using ZipResult = (string? Error, string? Path, string[] Files);

/// <summary>
/// A service for interacting with zip files of images
/// </summary>
public interface IZipService
{
	/// <summary>
	/// Generates an image URL that resolves to a ZIP file
	/// </summary>
	/// <param name="url">The URL of the zip file</param>
	/// <param name="filename">The name of the file</param>
	/// <returns>The generated image URL</returns>
	string GenerateImageUrl(string url, string filename);

	/// <summary>
	/// Parses a image URL generated by <see cref="GenerateImageUrl"/>
	/// </summary>
	/// <param name="imageUrl">The URL of the image</param>
	/// <param name="url">The url of the zip file</param>
	/// <param name="filename">The file name in the zip</param>
	/// <returns>Whether or not the file name was parsed correctly</returns>
	bool ParseImageUrl(string imageUrl, out string url, out string filename);

	/// <summary>
	/// Downloads the given zip file
	/// </summary>
	/// <param name="url">The URL to download</param>
	/// <param name="headers">Optional headers for the request</param>
	/// <param name="token">The cancellation token for the request</param>
	/// <returns>The result of the zip download</returns>
	Task<ZipResult> DownloadZip(string url, Headers? headers, CancellationToken token);

	/// <summary>
	/// Fetches the image result for a zip-image
	/// </summary>
	/// <param name="source">The source of the manga</param>
	/// <param name="manga">The manga the image belongs to</param>
	/// <param name="image">The image to download</param>
	/// <param name="path">The cache path for the image</param>
	/// <param name="hash">The hash for the image URL</param>
	/// <param name="overrideOrdinal">The optional override ordinal for the images</param>
	/// <param name="token">The cancellation token for the request</param>
	/// <returns>The result of the image</returns>
	Task<ImageResult?> Get(MbSource source, MbManga manga, MbImage image, string path, string hash, int? overrideOrdinal, CancellationToken token);
}

internal class ZipService(
	IHttpService _http,
	ICacheService _cache,
	ILogger<ZipService> _logger) : IZipService
{
	private readonly ConcurrentDictionary<string, Task<ZipResult>> _zipDownloads = [];

	/// <inheritdoc />
	public string GenerateImageUrl(string url, string filename)
	{
		var b64 = Encoding.UTF8.GetBytes(filename).ToBase64();
		return $"zip://{b64}:{url}";
	}

	/// <inheritdoc />
	public bool ParseImageUrl(string imageUrl, out string url, out string filename)
	{
		url = string.Empty;
		filename = string.Empty;

		if (!imageUrl.StartsWithIc("zip://")) return false;

		var parts = imageUrl["zip://".Length..].Split(':', 2);
		if (parts.Length != 2) return false;

		filename = Encoding.UTF8.GetString(Convert.FromBase64String(parts[0]));
		url = parts[1];
		return true;
	}

	/// <inheritdoc />
	public async Task<ImageResult?> Get(MbSource source, MbManga manga, MbImage image, string path, string hash, int? overrideOrdinal, CancellationToken token)
	{
		if (!ParseImageUrl(image.Url, out var zipUrl, out var filename)) 
			return null;

		var headers = _http.HeadersFrom(zipUrl, source, manga, image);
		var (error, zipPath, files) = await DownloadZip(zipUrl, headers, token);
		if (!string.IsNullOrEmpty(error) || string.IsNullOrEmpty(zipPath))
			return new(error ?? "Unknown error downloading zip", image, OverrideOrdinal: overrideOrdinal);

		if (!files.Contains(filename))
			return new("File not found in zip: " + filename, image, OverrideOrdinal: overrideOrdinal);

		var actualFileName = Path.GetFileName(filename);
		if (string.IsNullOrEmpty(actualFileName))
			return new("Invalid file name in zip: " + filename, image, OverrideOrdinal: overrideOrdinal);

		using var zip = ZipFile.OpenRead(zipPath);
		var entry = zip.GetEntry(filename);
		if (entry is null)
			return new("File not found in zip (2): " + filename, image, OverrideOrdinal: overrideOrdinal);

		image.MimeType ??= _http.DetermineMimeType(actualFileName);
		image.ImageSize ??= entry.Length;
		image.UrlHash ??= hash;
		image.FileName ??= entry.Name;

		using var io = File.Create(path);
		using var entryStream = entry.Open();
		await entryStream.CopyToAsync(io, token);
		await io.FlushAsync(token);
		await io.DisposeAsync();

		if (image.ImageWidth is null || image.ImageHeight is null)
		{
			var (width, height) = await _http.DetermineImageSize(path);
			image.ImageWidth = width ?? image.ImageWidth;
			image.ImageHeight = height ?? image.ImageHeight;
		}

		return new(null, image, File.OpenRead(path), false, OverrideOrdinal: overrideOrdinal);
	}

	/// <inheritdoc />
	public Task<ZipResult> DownloadZip(string url, Headers? headers, CancellationToken token)
	{
		if (_zipDownloads.TryGetValue(url, out var existing))
			return existing;

		return _zipDownloads[url] = RawDownloadZip(url, headers, token);
	}

	/// <summary>
	/// Downloads the zip file and caches it
	/// </summary>
	/// <param name="url">The URL to the zip file</param>
	/// <param name="headers">Optional headers for the request</param>
	/// <param name="token">The cancellation token for the request</param>
	/// <returns>The result of the zip download</returns>
	public async Task<ZipResult> RawDownloadZip(string url, Headers? headers, CancellationToken token)
	{
		static ZipResult FromZip(string path)
		{
			using var zip = ZipFile.OpenRead(path);
			var entries = zip.Entries.Select(e => e.FullName).ToArray();
			return (null, path, entries);
		}

		try
		{
			var cachePath = _cache.GetZipCachePath(url, out _);
			if (File.Exists(cachePath)) return FromZip(cachePath);

			using var download = await _http.Download(url, headers, token);
			if (!string.IsNullOrEmpty(download.Error) || download.Stream is null)
				return (download.Error, null, []);

			using var io = File.Create(cachePath);
			await download.Stream.CopyToAsync(io, token);
			await io.FlushAsync(token);
			await io.DisposeAsync();

			return FromZip(cachePath);
		}
		catch (Exception ex)
		{
			_logger.LogError(ex, "Failed to read zip cache for {Url}", url);
			throw;
		}
		finally
		{
			_zipDownloads.TryRemove(url, out _);
		}
	}
}
